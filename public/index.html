<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#000000">
  <title>Ralph Terminal</title>
  <style>
    :root {
      --bg-color: #0c0c0c;
      --text-color: #cccccc;
      --prompt-color: #4ade80;
      --cmd-color: #ffffff;
      --error-color: #ef4444;
      --success-color: #4ade80;
      --info-color: #60a5fa;
      --link-color: #a78bfa;
      --font-stack: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: var(--font-stack);
      font-size: 14px;
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #terminal {
      flex: 1;
      padding: 10px;
      padding-top: calc(10px + env(safe-area-inset-top));
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      word-break: break-all;
    }

    .line {
      margin-bottom: 2px;
      white-space: pre-wrap;
      line-height: 1.4;
    }

    .line.error { color: var(--error-color); }
    .line.success { color: var(--success-color); }
    .line.info { color: var(--info-color); }
    .line.system { color: #666; font-style: italic; }

    .input-area {
      display: flex;
      align-items: center;
      padding: 10px;
      padding-bottom: calc(10px + env(safe-area-inset-bottom));
      background: rgba(255, 255, 255, 0.05);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .prompt {
      color: var(--prompt-color);
      margin-right: 8px;
      font-weight: bold;
      white-space: nowrap;
    }

    #cmd-input {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--cmd-color);
      font-family: var(--font-stack);
      font-size: 16px; /* Prevents iOS zoom */
      outline: none;
      padding: 0;
      margin: 0;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: var(--bg-color);
    }
    ::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 4px;
    }

    /* Mobile adjustments */
    @media (max-width: 600px) {
      body {
        font-size: 13px;
      }
      #cmd-input {
        font-size: 16px;
      }
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin: 5px 0;
    }
    th, td {
      text-align: left;
      padding-right: 15px;
      vertical-align: top;
    }
    th {
      color: #888;
      border-bottom: 1px solid #333;
    }
  </style>
</head>
<body>
  <div id="terminal" onclick="document.getElementById('cmd-input').focus()">
    <div class="line system">Ralph Terminal v2.0.0</div>
    <div class="line system">Type '/help' for available commands.</div>
    <div class="line system">----------------------------------------</div>
  </div>

  <div class="input-area">
    <span class="prompt">ralph&gt;</span>
    <input type="text" id="cmd-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" autofocus>
  </div>

  <script>
    const term = document.getElementById('terminal');
    const input = document.getElementById('cmd-input');

    // State
    const history = [];
    let historyIndex = -1;
    let ws = null;

    // Auto-focus input
    document.addEventListener('click', () => input.focus());

    // Input handling
    input.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter') {
        const cmd = input.value.trim();
        if (cmd) {
          history.push(cmd);
          historyIndex = history.length;
          addLine(`ralph> ${cmd}`, 'default');
          input.value = '';
          await processCommand(cmd);
        }
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (historyIndex > 0) {
          historyIndex--;
          input.value = history[historyIndex];
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (historyIndex < history.length - 1) {
          historyIndex++;
          input.value = history[historyIndex];
        } else {
          historyIndex = history.length;
          input.value = '';
        }
      }
    });

    // Output handling
    function addLine(content, type = 'default') {
      const div = document.createElement('div');
      div.className = `line ${type}`;

      if (typeof content === 'object' && content !== null) {
        if (content.table && content.node) {
          div.appendChild(content.node);
        } else {
           div.textContent = JSON.stringify(content, null, 2);
        }
      } else {
        div.textContent = content;
      }

      term.appendChild(div);
      term.scrollTop = term.scrollHeight;
    }

    function createTable(headers, rows) {
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const trHead = document.createElement('tr');
      headers.forEach(h => {
        const th = document.createElement('th');
        th.textContent = h;
        trHead.appendChild(th);
      });
      thead.appendChild(trHead);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      rows.forEach(row => {
        const tr = document.createElement('tr');
        row.forEach(cell => {
          const td = document.createElement('td');
          td.textContent = cell;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      return { table: true, node: table };
    }

    // Command Processor
    async function processCommand(rawCmd) {
      const parts = rawCmd.split(' ');
      const cmd = parts[0].toLowerCase();
      const args = parts.slice(1);

      // Support both /cmd and cmd
      const cleanCmd = cmd.startsWith('/') ? cmd.slice(1) : cmd;

      switch(cleanCmd) {
        case 'help':
          const helpData = [
            ['/repos', 'List repositories'],
            ['/clone <url>', 'Clone a repository'],
            ['/jobs', 'List active jobs'],
            ['/start <repo>', 'Start Ralph loop on repo'],
            ['/manager <repo> "<req>"', 'Start Manager on repo'],
            ['/stop <id>', 'Stop a job by ID'],
            ['/costs', 'Show session costs'],
            ['/status <repo>', 'Show git status'],
            ['/clear', 'Clear screen']
          ];
          addLine(createTable(['Command', 'Description'], helpData));
          break;

        case 'clear':
        case 'cls':
          term.innerHTML = '';
          break;

        case 'repos':
        case 'ls':
          await fetchRepos();
          break;

        case 'clone':
          if (!args[0]) {
            addLine('Usage: /clone <url>', 'error');
            break;
          }
          await cloneRepo(args[0]);
          break;

        case 'jobs':
          await fetchJobs();
          break;

        case 'start':
          if (!args[0]) {
            addLine('Usage: /start <repo_name>', 'error');
            break;
          }
          await startRalph(args[0]);
          break;

        case 'manager':
          if (args.length < 2) {
            addLine('Usage: /manager <repo_name> "your request"', 'error');
            break;
          }
          // Handle quoted string for request
          const repo = args[0];
          // Reconstruct the request string from remaining args
          const request = rawCmd.substring(rawCmd.indexOf(repo) + repo.length).trim().replace(/^"|"$/g, '');
          await startManager(repo, request);
          break;

        case 'stop':
          if (!args[0]) {
            addLine('Usage: /stop <job_id>', 'error');
            break;
          }
          await stopJob(args[0]);
          break;

        case 'costs':
          await fetchCosts();
          break;

        case 'status':
          if (!args[0]) {
            addLine('Usage: /status <repo_name>', 'error');
            break;
          }
          await fetchGitStatus(args[0]);
          break;

        default:
          addLine(`Unknown command: ${cleanCmd}. Type /help for assistance.`, 'error');
      }
    }

    // API Functions
    async function fetchRepos() {
      addLine('Fetching repos...', 'system');
      try {
        const res = await fetch('/api/repos');
        const repos = await res.json();
        if (repos.length === 0) {
          addLine('No repositories found.', 'info');
          return;
        }

        const rows = repos.map(r => {
          let status = 'Ready';
          if (r.prd && r.prd.userStories) {
            const done = r.prd.userStories.filter(s => s.passes).length;
            const total = r.prd.userStories.length;
            status = `${done}/${total} done`;
          }
          return [r.name, status];
        });

        addLine(createTable(['Name', 'Status'], rows));
      } catch (e) {
        addLine(`Error: ${e.message}`, 'error');
      }
    }

    async function cloneRepo(url) {
      addLine(`Cloning ${url}...`, 'system');
      try {
        const res = await fetch('/api/repos/clone', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url })
        });
        const data = await res.json();

        if (res.ok) {
          addLine(`Successfully cloned ${data.name}`, 'success');
        } else {
          addLine(`Failed: ${data.error}`, 'error');
        }
      } catch (e) {
        addLine(`Error: ${e.message}`, 'error');
      }
    }

    async function fetchJobs() {
      try {
        const res = await fetch('/api/jobs');
        const jobs = await res.json();
        if (jobs.length === 0) {
          addLine('No active jobs.', 'info');
          return;
        }

        const rows = jobs.map(j => [
          j.id,
          j.type,
          j.repo,
          j.status,
          `$${(j.cost || 0).toFixed(4)}`
        ]);

        addLine(createTable(['ID', 'Type', 'Repo', 'Status', 'Cost'], rows));
      } catch (e) {
        addLine(`Error: ${e.message}`, 'error');
      }
    }

    async function startRalph(repo) {
      addLine(`Starting Ralph loop on ${repo}...`, 'system');
      try {
        const res = await fetch('/api/ralph', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ repo })
        });
        const data = await res.json();

        if (res.ok) {
          addLine(`Job started (ID: ${data.jobId})`, 'success');
        } else {
          addLine(`Failed: ${data.error}`, 'error');
        }
      } catch (e) {
        addLine(`Error: ${e.message}`, 'error');
      }
    }

    async function startManager(repo, request) {
      addLine(`Starting Manager on ${repo}...`, 'system');
      try {
        const res = await fetch('/api/manager', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ repo, request })
        });
        const data = await res.json();

        if (res.ok) {
          addLine(`Manager job started (ID: ${data.jobId})`, 'success');
        } else {
          addLine(`Failed: ${data.error}`, 'error');
        }
      } catch (e) {
        addLine(`Error: ${e.message}`, 'error');
      }
    }

    async function stopJob(id) {
      try {
        const res = await fetch(`/api/jobs/${id}/stop`, { method: 'POST' });
        if (res.ok) {
          addLine(`Job ${id} stopped.`, 'success');
        } else {
          const data = await res.json();
          addLine(`Failed: ${data.error}`, 'error');
        }
      } catch (e) {
        addLine(`Error: ${e.message}`, 'error');
      }
    }

    async function fetchCosts() {
      try {
        const res = await fetch('/api/costs');
        const data = await res.json();

        const rows = [
          ['Total Spent', `$${data.totalCost}`],
          ['Budget Left', `$${data.budgetRemaining}`],
          ['Manager Calls', data.managerCalls],
          ['Ralph Iterations', data.ralphIterations]
        ];

        addLine(createTable(['Metric', 'Value'], rows));
      } catch (e) {
        addLine(`Error: ${e.message}`, 'error');
      }
    }

    async function fetchGitStatus(repo) {
      try {
        const res = await fetch(`/api/repos/${repo}/git/status`);
        const data = await res.json();

        if (res.ok) {
            const rows = [
                ['Branch', data.branch],
                ['Changes', data.changes],
                ['Clean', data.clean ? 'Yes' : 'No'],
                ['Ahead', data.ahead],
                ['Behind', data.behind]
            ];
            addLine(createTable(['Property', 'Value'], rows));

            if (data.changedFiles && data.changedFiles.length > 0) {
                addLine('Changed Files:', 'info');
                data.changedFiles.forEach(f => {
                    addLine(`  ${f.status} ${f.file}`, 'default');
                });
            }
        } else {
            addLine(`Error: ${data.error}`, 'error');
        }
      } catch (e) {
        addLine(`Error: ${e.message}`, 'error');
      }
    }

    // WebSocket
    function connectWS() {
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${location.host}`);

      ws.onopen = () => {
        addLine('[WS] Connected to server', 'success');
      };

      ws.onclose = () => {
        addLine('[WS] Disconnected. Reconnecting...', 'error');
        setTimeout(connectWS, 3000);
      };

      ws.onmessage = (e) => {
        const data = JSON.parse(e.data);
        handleWSMessage(data);
      };
    }

    function handleWSMessage(data) {
      switch(data.type) {
        case 'job_started':
          addLine(`[JOB] Started ${data.job.type} on ${data.job.repo} (ID: ${data.jobId})`, 'info');
          break;
        case 'job_completed':
          addLine(`[JOB] Job ${data.jobId} ${data.status}`, data.status === 'completed' ? 'success' : 'error');
          break;
        case 'log':
          // Simply print the log line.
          // For a terminal, we might want to trim it or format it slightly if it's very long
          addLine(data.data.trim(), 'default');
          break;
        case 'git_commit':
          addLine(`[GIT] Committed: ${data.hash} - ${data.message}`, 'success');
          break;
        case 'git_push':
          addLine(`[GIT] Pushed to ${data.branch}`, 'success');
          break;
      }
    }

    // Init
    connectWS();
  </script>
</body>
</html>
